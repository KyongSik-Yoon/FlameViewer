package com.github.korniloval.flameviewer

import com.github.korniloval.flameviewer.converters.calltree.fierix.FierixToCallTreeConverter
import com.github.korniloval.flameviewer.server.NAME
import com.intellij.openapi.application.PathManager
import com.intellij.openapi.diagnostic.Logger
import org.jetbrains.annotations.TestOnly
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.net.URISyntaxException
import java.nio.file.Path
import java.nio.file.Paths
import java.text.SimpleDateFormat
import java.util.*
import java.util.regex.Pattern

/**
 * IDEA system dir
 * |-- flamegraph-profiler
 * ....|-- log
 * ....|-- deleted // deleted files temporary stored in this dir (they are returned back if `undo` is pressed)
 * ....|-- uploaded-files
 * ........|-- not-converted // files are stored here before conversion
 * ........|-- ser // uploaded .ser files generated by Fierix (deprecated)
 * ........|-- fierix // uploaded .fierix files generated by Fierix
 */
object PluginFileManager {
    private val LOG = Logger.getInstance(PluginFileManager::class.java)

    private const val PLUGIN_DIR_NAME = "flamegraph-profiler"
    private const val LOG_DIR_NAME = "log"
    private const val STATIC_DIR_NAME = "static"
    private const val REQUEST_PREFIX = "/$NAME/"
    private const val UPLOADED_FILES = "uploaded-files"
    private const val DELETED_FILES = "deleted"
    private const val NOT_CONVERTED = "not-converted"

    val tempFileSaver: FileSaver // save files before converting
    val logDirPath: Path // for tests
    private val uploadedFilesDir: File
    private val staticDirPath: Path?

    init {
        val systemDirPath = PathManager.getSystemPath()
        val systemDir = Paths.get(systemDirPath)
        val pluginDir = Paths.get(systemDir.toString(), PLUGIN_DIR_NAME)
        createDirIfNotExist(pluginDir)
        logDirPath = Paths.get(pluginDir.toString(), LOG_DIR_NAME)
        createDirIfNotExist(logDirPath)
        try {
            val staticDirUrl = javaClass.getResource("/$STATIC_DIR_NAME")
            if (staticDirUrl != null) {
                staticDirPath = Paths.get(staticDirUrl.toURI())
            } else {
                /* happens when tests are run from IDE */
                staticDirPath = null
                LOG.warn("$pleaseReportIssue: Cannot find static dir. javaClass.getResource returned null")
            }
        } catch (e: URISyntaxException) {
            throw AssertionError("$pleaseReportIssue: Cannot find static dir: ${javaClass.getResource("/$STATIC_DIR_NAME")}", e)
        }

        val uploadedFilesPath = Paths.get(logDirPath.toString(), UPLOADED_FILES)
        createDirIfNotExist(uploadedFilesPath)
        uploadedFilesDir = uploadedFilesPath.toFile()

        val deletedFilesPath = Paths.get(logDirPath.toString(), DELETED_FILES)
        createDirIfNotExist(deletedFilesPath)

        val notConvertedFiles = Paths.get(uploadedFilesPath.toString(), NOT_CONVERTED)
        createDirIfNotExist(notConvertedFiles)
        tempFileSaver = FileSaver(notConvertedFiles)

        finallyDeleteRemovedFiles()
        removeEmptyProjects()
    }

    private fun finallyDeleteRemovedFiles(): Boolean {
        val deletedFilesDir = Paths.get(logDirPath.toString(), DELETED_FILES).toFile()
        if (!deletedFilesDir.exists() || !deletedFilesDir.isDirectory) {
            LOG.debug("Directory with deleted files was not found")
            return false
        }
        val files = deletedFilesDir.listFiles()
        files ?: return true
        return files.map { it.delete() }.all { it } // all files were deleted
    }

    private fun getAllStoredFiles(): List<File> {
        val files = mutableListOf<File>()
        val dirs = logDirPath.toFile().listFiles() ?: return emptyList()
        for (dir in dirs) {
            if (!dir.exists() || !dir.isDirectory || dir.name == DELETED_FILES) continue
            if (dir.name == UPLOADED_FILES) {
                dir.listFiles()?.filter { it.name != NOT_CONVERTED }?.forEach { addFiles(it, files) }
            } else {
                addFiles(dir, files)
            }
        }
        return files
    }

    private fun addFiles(dir: File, fileList: MutableList<File>) {
        if (!dir.exists() || !dir.isDirectory) return
        val files = dir.listFiles() ?: return
        for (file in files) {
            if (file.isFile) fileList.add(file)
        }
    }

    private fun forEachStoredFile(file: File, action: (File) -> Unit) {
        if (file.isFile) action(file)
        else if (file.isDirectory) {
            val files = file.listFiles() ?: return
            for (innerFile in files) forEachStoredFile(innerFile, action)
        }
    }

    @Synchronized
    fun getFileNameList(): List<FileNameAndDate> {
        val fileNames = ArrayList<FileNameAndDate>()
        val files = getAllStoredFiles()
        files.sortedBy { it.lastModified() }
                .mapTo(fileNames) { FileNameAndDate(it) }
        return fileNames
    }

    @Synchronized
    fun getStaticFile(staticFileUri: String): File {
        return Paths.get(
                staticDirPath.toString(),
                staticFileUri.substring(REQUEST_PREFIX.length, staticFileUri.length)
        ).toFile()
    }

    @Synchronized
    fun getLogFile(fileName: String): File? = getAllStoredFiles().firstOrNull { it.name == fileName }

    private fun removeEmptyProjects() {
        val logDir = logDirPath.toFile()
        val projects = logDir.listFiles() ?: return
        for (project in projects) {
            if (!project.isDirectory) continue
            if (project.name == UPLOADED_FILES || project.name == DELETED_FILES) {
                continue
            }
            val projectFiles = project.listFiles()
            if (projectFiles == null || projectFiles.isEmpty()) {
                project.delete()
            }
        }
    }

    @TestOnly
    @Synchronized
    fun deleteAllUploadedFiles() {
        val dirsInsideUploadedFiles = uploadedFilesDir.listFiles() ?: return
        for (maybeDir in dirsInsideUploadedFiles) {
            if (maybeDir.isDirectory) {
                val files = maybeDir.listFiles() ?: continue
                for (file in files) {
                    val res = file.delete()
                    if (!res) {
                        System.err.println("Cannot delete file: $file")
                    }
                }
            }
        }
    }

    @Synchronized
    fun deleteFile(fileName: String) {
        val file = getLogFile(fileName) ?: return
        /* uploaded files are stored in separate directories
         * (name of a directory is an id of converter that is responsible for the file)
         * when we move file to temporal directory we want to save converter id,
         * so if delete action is undone we can move file back to needed directory */
        if (file.parentFile?.parentFile?.name != "uploaded-files") {
            file.renameTo(Paths.get(logDirPath.toString(), DELETED_FILES, fileName).toFile())
            return
        }
        val converterId = file.parentFile.name
        val newDir = Paths.get(logDirPath.toString(), DELETED_FILES, converterId).toFile()
        if (!newDir.exists()) {
            if (!newDir.mkdir()) {
                LOG.warn("Cannot create directory to move deleted file. File: $file Dir: $newDir")
                return
            }
        }
        file.renameTo(Paths.get(newDir.toString(), fileName).toFile())
    }

    @Synchronized
    fun undoDeleteFile(fileName: String) {
        val deletedFile = getDeletedFile(fileName)
        if (deletedFile == null || !deletedFile.exists()) {
            LOG.debug("Undo delete. Cannot find file to undo delete: $fileName")
            return
        }
        val projectDirPath = if (deletedFile.parentFile?.parentFile?.name == DELETED_FILES) {
            val converterId = deletedFile.parentFile.name
            Paths.get(logDirPath.toString(), UPLOADED_FILES, converterId).toFile()
        } else {
            // some fierix files were stored in project-specific directories. This layout is deprecated.
            // So move them to fierix dir.
            Paths.get(logDirPath.toString(), UPLOADED_FILES, FierixToCallTreeConverter.EXTENSION).toFile()
        }

        createDirIfNotExist(projectDirPath.toPath())

        val res = deletedFile.renameTo(Paths.get(projectDirPath.toString(), fileName).toFile())
        if (!res) {
            LOG.warn("Cannot move file back from temp directory. File: $fileName")
        }
    }

    private fun getDeletedFile(fileName: String): File? {
        val deletedFilesDir = Paths.get(logDirPath.toString(), DELETED_FILES).toFile()
        var file: File? = null
        forEachStoredFile(deletedFilesDir) { f ->
            if (f.name == fileName) {
                file = f
                return@forEachStoredFile
            }
        }
        return file
    }

    fun moveFileToUploadedFiles(converterId: String, fileName: String, file: File) {
        val dir = Paths.get(uploadedFilesDir.toString(), converterId)
        createDirIfNotExist(dir)
        val newFile = Paths.get(dir.toString(), fileName).toFile()
        if (!file.renameTo(newFile))
            LOG.error("Cannot move file $file to $converterId directory.")
    }

    class FileNameAndDate(file: File) {
        private val name: String
        private val fullName: String = file.name
        private val date: String
        /**
         * id is used as css id
         */
        private val id: String

        init {
            val stringBuilder = StringBuilder()
            for (i in 0 until file.name.length) {
                val c = file.name[i]
                if (c in 'A'..'Z' || c in 'a'..'z' || c in '0'..'9' || c == '-' || c == '_') { // if allowed by css
                    stringBuilder.append(c)
                } else {
                    stringBuilder.append('_')
                }
            }
            this.id = "id-$stringBuilder"
            val matcher = nameWithoutDate.matcher(this.fullName)
            if (matcher.find()) {
                this.name = matcher.group()
            } else {
                this.name = fullName
            }
            this.date = SimpleDateFormat("dd.MM.yyyy HH:mm:ss").format(Date(file.lastModified()))
        }

        companion object {
            private val nameWithoutDate = Pattern.compile(".*(?=-\\d\\d\\d\\d-\\d\\d-\\d\\d-\\d\\d_\\d\\d_\\d\\d(.*)?)")
        }
    }

    class FileSaver internal constructor(private val dir: Path) {
        fun save(bytes: ByteArray, fileName: String): File? {
            val file = Paths.get(dir.toString(), fileName).toFile()
            try {
                FileOutputStream(file).use { outputStream ->
                    outputStream.write(bytes)
                    return file
                }
            } catch (e: IOException) {
                LOG.error(e)
            }

            return null
        }
    }

    private fun createDirIfNotExist(path: Path) {
        val dir = File(path.toString())
        if (!dir.exists()) {
            try {
                assert(dir.mkdir())
            } catch (se: SecurityException) {
                LOG.error(se)
            }
        }
    }
}
